# ABN AMRO Recipes application

## Local setup
### System Requirements
1. Java 17
2. Docker and docker-compose
3. maven
4. newman (Optional: for cli run of integration tests)
### Execute
To build the application
> mvn clean install

To run the application
1. Run elastic search database using docker-compose
> docker-compose up

2. Run recipes application
> mvn spring-boot:run

### Unit Tests
Unit tests can be run using
> mvn test

### Integration tests
Postman collection can be run either using GUI Postman app or from cli using newman
> newman run RecipeAppTest.postman_collection.json

## Architecture
Explanation of Recipe rest application's system architecture and the rationale behind it
### Data Model Analysis
Below factors make the data schema lean towards noSQL (as per the requirements)
1. Ability to free text search within instructions
2. ingredients - There is a choice to model ingredient as a separate entity and compose it in Recipe, if we are want to normalize data model. However, this complicates API usage, where the user will have to store/retrieve ingredients first and then use the Ids to define relations. It would be okay to have some level of data duplication and rather keep ingredients are a list of string within recipe.
3. Lack of transactional nature of data - as assumption made from current requirements.
### Data Model
I have defined a single data model - 

> Recipe(id, name, serving, ingredients, instructions, isVegetarian)
### Layers
Application has the following layers:
1. Controller - Auto generated from openapi yaml
2. ServiceDelegate - Service layer implements the Controller methods and extends it with additional business logic. Nowadays its a best practice to keep zero logic inside controller. Now given my controller is autogenerated I chose to skip having a concrete implementation of it.
3. Data (Repository) - deals with database operations

### API definition
Refer to the src/main/resources/openapi.yml

You can also open the postman collection in Postman UI.

(Note : I could not complete swagger docs generation from openai spec, as was the original plan)

### REST maturity level
This application has REST maturity [level 2.3](https://martinfowler.com/articles/richardsonMaturityModel.html#level2) 
### REST naming conventions
Singular noun used for all CRUD operations (/recipe - for all operations), HTTP verb utilised to identify action.

Case: kebab-case for path and query parameters
### Choice of frameworks/tools
#### 1. openapi code-gen
openapi code-gen has following benefits:
1. Automated server generation (boiler plate code)
2. Centralised resource definition for API definition
3. Automated Client generation supported (in consumer services)
4. Ability to generate swagger docs

#### 2. spring-data
Mature ORM supports elastic search, reduces boilerplate code again.

#### 3. Postman
For integration tests I have picked postman due to:
1. Interoperability with QA team
2. Test isolation at REST level (indifferent to Java language)

#### 4. ElasticSearch
ElasticSearch has inbuilt free text search capabilities which is quite faster than a SQL "like" search. We can extend current customFilter to even enable fuzzy search by supplying word distance in the query.

## TODO:
This list of items are a must for the application to be production ready but not done due to lack of time.
1. Security
   1. Security can be implemented using spring-security using jwk/jwt tokens
   2. User can be inferred from the token and userId to supplemented in all db queries
2. Spring authorization server
    1. Spring authorization server can be configured to run along with the Recipes App in absence of a central auth server.
3. Unit tests
   1. Need to improve coverage
4. CI/CD - run in docker-compose
   1. Ideally app should be run along with ES within same docker-compose.
5. logging - ELK or similar log aggregation
6. UML diagrams - Class and Sequence diagrams

### Good to have:
These are good to have items in addition to the above list.
1. BDD - cucumber
